diff --git a/drivers/Makefile b/drivers/Makefile
index aaef17cc6512..66dd9525d5c5 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -58,6 +58,9 @@ obj-y				+= char/
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-y				+= iommu/
 
+# i2c/ i3c/ come before gpu as gpu are using i2c controllers
+obj-y				+= i2c/ i3c/ media/
+
 # gpu/ comes after char for AGP vs DRM startup and after iommu
 obj-y				+= gpu/
 
@@ -110,7 +113,7 @@ obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
-obj-y				+= i2c/ i3c/ media/
+#obj-y				+= i2c/ i3c/ media/
 obj-$(CONFIG_PPS)		+= pps/
 obj-y				+= ptp/
 obj-$(CONFIG_W1)		+= w1/
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 10e2273c89c5..d4f4e709af8b 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -251,6 +251,13 @@ config CLK_QORIQ
 	  This adds the clock driver support for Freescale QorIQ platforms
 	  using common clock framework.
 
+config COMMON_CLK_DGLNT_DYNCLK
+	tristate "Digilent axi_dynclk Driver"
+	depends on ARCH_ZYNQ || MICROBLAZE
+	---help---
+	  Support for the Digilent AXI Dynamic Clock core for Xilinx
+	  FPGAs.
+
 config COMMON_CLK_XGENE
 	bool "Clock driver for APM XGene SoC"
 	default ARCH_XGENE
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 0c05b403af91..95984b47266a 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_COMMON_CLK_BD718XX)	+= clk-bd718x7.o
 obj-$(CONFIG_COMMON_CLK_CDCE706)	+= clk-cdce706.o
 obj-$(CONFIG_COMMON_CLK_CDCE925)	+= clk-cdce925.o
 obj-$(CONFIG_ARCH_CLPS711X)		+= clk-clps711x.o
+obj-$(CONFIG_COMMON_CLK_DGLNT_DYNCLK)	+= clk-dglnt-dynclk.o
 obj-$(CONFIG_COMMON_CLK_CS2000_CP)	+= clk-cs2000-cp.o
 obj-$(CONFIG_ARCH_EFM32)		+= clk-efm32gg.o
 obj-$(CONFIG_COMMON_CLK_FIXED_MMIO)	+= clk-fixed-mmio.o
diff --git a/drivers/clk/clk-dglnt-dynclk.c b/drivers/clk/clk-dglnt-dynclk.c
new file mode 100644
index 000000000000..d4afe7f51787
--- /dev/null
+++ b/drivers/clk/clk-dglnt-dynclk.c
@@ -0,0 +1,647 @@
+/*  clk-dglnt-dynclk.c - The simplest kernel module.
+
+* Copyright (C) 2013 - 2016 Xilinx, Inc
+*
+*   This program is free software; you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation; either version 2 of the License, or
+*   (at your option) any later version.
+
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License along
+*   with this program. If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+
+/* BEGIN - Standard module information, edit as appropriate */
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sam Bobrowicz <sbobrowicz@digilentinc.com>");
+MODULE_DESCRIPTION("clk-dglnt-dynclk - CCF Driver for Digilent axi_dynclk IP Core");
+
+#define DRIVER_NAME "clk-dglnt-dynclk"
+
+/* END - Standard module information, edit as appropriate */
+
+#define CLK_BIT_WEDGE			13
+#define CLK_BIT_NOCOUNT			12
+
+#define CLK_BIT_WEDGE			13
+#define CLK_BIT_NOCOUNT			12
+
+/* This value is used to signal an error */
+#define ERR_CLKCOUNTCALC		0xFFFFFFFF
+#define ERR_CLKDIVIDER			(1 << CLK_BIT_WEDGE | 1 << CLK_BIT_NOCOUNT)
+
+#define DYNCLK_DIV_1_REGMASK		0x1041
+/* 25 MHz (125 KHz / 5) */
+#define DYNCLK_DEFAULT_FREQ		125000
+
+#define MMCM_FREQ_VCOMIN		600000
+#define MMCM_FREQ_VCOMAX		1200000
+#define MMCM_FREQ_PFDMIN		10000
+#define MMCM_FREQ_PFDMAX		450000
+#define MMCM_FREQ_OUTMIN		4000
+#define MMCM_FREQ_OUTMAX		800000
+#define MMCM_DIV_MAX			106
+#define MMCM_FB_MIN			2
+#define MMCM_FB_MAX			64
+#define MMCM_CLKDIV_MAX			128
+#define MMCM_CLKDIV_MIN			1
+
+#define OFST_DISPLAY_CTRL		0x0
+#define OFST_DISPLAY_STATUS		0x4
+#define OFST_DISPLAY_CLK_L		0x8
+#define OFST_DISPLAY_FB_L		0x0C
+#define OFST_DISPLAY_FB_H_CLK_H		0x10
+#define OFST_DISPLAY_DIV		0x14
+#define OFST_DISPLAY_LOCK_L		0x18
+#define OFST_DISPLAY_FLTR_LOCK_H	0x1C
+
+
+static const u64 lock_lookup[64] =
+{
+	0b0011000110111110100011111010010000000001,
+	0b0011000110111110100011111010010000000001,
+	0b0100001000111110100011111010010000000001,
+	0b0101101011111110100011111010010000000001,
+	0b0111001110111110100011111010010000000001,
+	0b1000110001111110100011111010010000000001,
+	0b1001110011111110100011111010010000000001,
+	0b1011010110111110100011111010010000000001,
+	0b1100111001111110100011111010010000000001,
+	0b1110011100111110100011111010010000000001,
+	0b1111111111111000010011111010010000000001,
+	0b1111111111110011100111111010010000000001,
+	0b1111111111101110111011111010010000000001,
+	0b1111111111101011110011111010010000000001,
+	0b1111111111101000101011111010010000000001,
+	0b1111111111100111000111111010010000000001,
+	0b1111111111100011111111111010010000000001,
+	0b1111111111100010011011111010010000000001,
+	0b1111111111100000110111111010010000000001,
+	0b1111111111011111010011111010010000000001,
+	0b1111111111011101101111111010010000000001,
+	0b1111111111011100001011111010010000000001,
+	0b1111111111011010100111111010010000000001,
+	0b1111111111011001000011111010010000000001,
+	0b1111111111011001000011111010010000000001,
+	0b1111111111010111011111111010010000000001,
+	0b1111111111010101111011111010010000000001,
+	0b1111111111010101111011111010010000000001,
+	0b1111111111010100010111111010010000000001,
+	0b1111111111010100010111111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001
+};
+
+static const u32 filter_lookup_low[64] =
+{
+	0b0001011111,
+	0b0001010111,
+	0b0001111011,
+	0b0001011011,
+	0b0001101011,
+	0b0001110011,
+	0b0001110011,
+	0b0001110011,
+	0b0001110011,
+	0b0001001011,
+	0b0001001011,
+	0b0001001011,
+	0b0010110011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011
+};
+
+struct dglnt_dynclk_reg;
+struct dglnt_dynclk_mode;
+struct dglnt_dynclk;
+
+struct dglnt_dynclk_reg
+{
+	u32 clk0L;
+	u32 clkFBL;
+	u32 clkFBH_clk0H;
+	u32 divclk;
+	u32 lockL;
+	u32 fltr_lockH;
+};
+
+struct dglnt_dynclk_mode
+{
+	u32 freq;
+	u32 fbmult;
+	u32 clkdiv;
+	u32 maindiv;
+};
+
+struct dglnt_dynclk
+{
+	void __iomem *base;
+	struct clk_hw clk_hw;
+	unsigned long freq;
+};
+
+
+u32 dglnt_dynclk_divider(u32 divide)
+{
+	u32 output = 0;
+	u32 highTime = 0;
+	u32 lowTime = 0;
+
+	if ((divide < 1) || (divide > 128))
+	{
+		return ERR_CLKDIVIDER;
+	}
+
+	if (divide == 1)
+	{
+		return DYNCLK_DIV_1_REGMASK;
+	}
+
+	highTime = divide / 2;
+	/* if divide is odd */
+	if (divide & 0x1)
+	{
+		lowTime = highTime + 1;
+		output = 1 << CLK_BIT_WEDGE;
+	}
+	else
+	{
+		lowTime = highTime;
+	}
+
+	output |= 0x03F & lowTime;
+	output |= 0xFC0 & (highTime << 6);
+	return output;
+}
+
+u32 dglnt_dynclk_count_calc(u32 divide)
+{
+	u32 output = 0;
+	u32 divCalc = 0;
+
+	divCalc = dglnt_dynclk_divider(divide);
+	if (divCalc == ERR_CLKDIVIDER)
+	{
+		output = ERR_CLKCOUNTCALC;
+	}
+	else
+	{
+		output = (0xFFF & divCalc) | ((divCalc << 10) & 0x00C00000);
+	}
+	return output;
+}
+
+
+int dglnt_dynclk_find_reg(struct dglnt_dynclk_reg *regValues,
+			  struct dglnt_dynclk_mode *clkParams)
+{
+	if ((clkParams->fbmult < 2) || clkParams->fbmult > 64)
+	{
+		return -EINVAL;
+	}
+
+	regValues->clk0L = dglnt_dynclk_count_calc(clkParams->clkdiv);
+	if (regValues->clk0L == ERR_CLKCOUNTCALC)
+	{
+		return -EINVAL;
+	}
+
+	regValues->clkFBL = dglnt_dynclk_count_calc(clkParams->fbmult);
+	if (regValues->clkFBL == ERR_CLKCOUNTCALC)
+	{
+		return -EINVAL;
+	}
+	regValues->clkFBH_clk0H = 0;
+
+	regValues->divclk = dglnt_dynclk_divider(clkParams->maindiv);
+	if (regValues->divclk == ERR_CLKDIVIDER)
+	{	
+		return -EINVAL;
+	}
+
+	regValues->lockL = (u32)(lock_lookup[clkParams->fbmult - 1] & 0xFFFFFFFF);
+
+	regValues->fltr_lockH = (u32)((lock_lookup[clkParams->fbmult - 1] >> 32) & 0x000000FF);
+	regValues->fltr_lockH |= ((filter_lookup_low[clkParams->fbmult - 1] << 16) & 0x03FF0000);
+
+	return 0;
+}
+
+void dglnt_dynclk_write_reg(struct dglnt_dynclk_reg *regValues,
+			    void __iomem *baseaddr)
+{
+	writel(regValues->clk0L, baseaddr + OFST_DISPLAY_CLK_L);
+	writel(regValues->clkFBL, baseaddr + OFST_DISPLAY_FB_L);
+	writel(regValues->clkFBH_clk0H, baseaddr + OFST_DISPLAY_FB_H_CLK_H);
+	writel(regValues->divclk, baseaddr + OFST_DISPLAY_DIV);
+	writel(regValues->lockL, baseaddr + OFST_DISPLAY_LOCK_L);
+	writel(regValues->fltr_lockH, baseaddr + OFST_DISPLAY_FLTR_LOCK_H);
+}
+
+u32 dglnt_dynclk_find_mode(u32 freq, u32 parentFreq,
+			   struct dglnt_dynclk_mode *bestPick)
+{
+	u32 bestError = MMCM_FREQ_OUTMAX;
+	u32 curError;
+	u32 curClkMult;
+	u32 curFreq;
+	u32 divVal;
+	u32 curFb, curClkDiv;
+	u32 minFb = 0;
+	u32 maxFb = 0;
+	u32 curDiv = 1;
+	u32 maxDiv;
+	bool freq_found = false;
+
+	bestPick->freq = 0;
+	if (parentFreq == 0)
+	{
+		return 0;
+	}
+
+	/* minimum frequency is actually dictated by VCOmin */
+	if (freq < MMCM_FREQ_OUTMIN)
+	{
+		freq = MMCM_FREQ_OUTMIN;
+	}
+
+	if (freq > MMCM_FREQ_OUTMAX)
+	{
+		freq = MMCM_FREQ_OUTMAX;
+	}
+
+	if (parentFreq > MMCM_FREQ_PFDMAX)
+	{
+		curDiv = 2;
+	}
+	maxDiv = parentFreq / MMCM_FREQ_PFDMIN;
+	if (maxDiv > MMCM_DIV_MAX)
+	{
+		maxDiv = MMCM_DIV_MAX;
+	}
+
+	while (curDiv <= maxDiv && !freq_found)
+	{
+		minFb = curDiv * DIV_ROUND_UP(MMCM_FREQ_VCOMIN, parentFreq);
+		maxFb = curDiv * (MMCM_FREQ_VCOMAX / parentFreq);
+		if (maxFb > MMCM_FB_MAX)
+		{
+			maxFb = MMCM_FB_MAX;
+		}
+		if (minFb < MMCM_FB_MIN)
+		{
+			minFb = MMCM_FB_MIN;
+		}
+
+		divVal = curDiv * freq;
+		/*
+		 * This multiplier is used to find the best clkDiv value for
+		 * each FB value
+		 */
+		curClkMult = ((parentFreq * 1000) + (divVal / 2)) / divVal;
+
+		curFb = minFb;
+		while (curFb <= maxFb && !freq_found)
+		{
+			curClkDiv = ((curClkMult * curFb) + 500) / 1000;
+			if (curClkDiv > MMCM_CLKDIV_MAX)
+			{
+				curClkDiv = MMCM_CLKDIV_MAX;
+			}
+			if (curClkDiv < MMCM_CLKDIV_MIN)
+			{
+				curClkDiv = MMCM_CLKDIV_MIN;
+			}
+			curFreq = (((parentFreq * curFb) / curDiv) / curClkDiv);
+			if (curFreq >= freq)
+			{
+				curError = curFreq - freq;
+			}
+			else
+			{
+				curError = freq - curFreq;
+			}
+			if (curError < bestError)
+			{
+				bestError = curError;
+				bestPick->clkdiv = curClkDiv;
+				bestPick->fbmult = curFb;
+				bestPick->maindiv = curDiv;
+				bestPick->freq = curFreq;
+			}
+			if (!curError)
+			{
+				freq_found = true;
+			}
+			curFb++;
+		}
+		curDiv++;
+	}
+	return bestPick->freq;
+}
+
+static struct dglnt_dynclk *clk_hw_to_dglnt_dynclk(struct clk_hw *clk_hw)
+{
+	return container_of(clk_hw, struct dglnt_dynclk, clk_hw);
+}
+
+static int dglnt_dynclk_enable(struct clk_hw *clk_hw)
+{
+	struct dglnt_dynclk *dglnt_dynclk = clk_hw_to_dglnt_dynclk(clk_hw);
+	unsigned int clock_state;
+
+	if (dglnt_dynclk->freq)
+	{
+		writel(1, dglnt_dynclk->base + OFST_DISPLAY_CTRL);
+		do
+		{
+			clock_state = readl(dglnt_dynclk->base + OFST_DISPLAY_STATUS);
+		}
+		while (!clock_state);
+	}
+	return 0;
+}
+
+static void dglnt_dynclk_disable(struct clk_hw *clk_hw)
+{
+	struct dglnt_dynclk *dglnt_dynclk = clk_hw_to_dglnt_dynclk(clk_hw);
+
+	writel(0, dglnt_dynclk->base + OFST_DISPLAY_CTRL);
+}
+
+static int dglnt_dynclk_set_rate(struct clk_hw *clk_hw,
+				 unsigned long rate, unsigned long parent_rate)
+{
+	struct dglnt_dynclk *dglnt_dynclk = clk_hw_to_dglnt_dynclk(clk_hw);
+	struct dglnt_dynclk_reg clkReg;
+	struct dglnt_dynclk_mode clkMode;
+
+	if (parent_rate == 0 || rate == 0)
+	{
+		return -EINVAL;
+	}
+	if (rate == dglnt_dynclk->freq)
+	{
+		return 0;
+	}
+
+	/*
+	 * Convert from Hz to KHz, then multiply by five to account for
+	 * BUFR division
+	 */
+	rate = (rate + 100) / 200;
+	/* convert from Hz to KHz */
+	parent_rate = (parent_rate + 500) / 1000;
+	if (!dglnt_dynclk_find_mode(rate, parent_rate, &clkMode))
+	{
+		return -EINVAL;
+	}
+
+	/*
+	 * Write to the PLL dynamic configuration registers to configure it
+	 * with the calculated parameters.
+	 */
+	dglnt_dynclk_find_reg(&clkReg, &clkMode);
+	dglnt_dynclk_write_reg(&clkReg, dglnt_dynclk->base);
+	dglnt_dynclk->freq = clkMode.freq * 200;
+	dglnt_dynclk_disable(clk_hw);
+	dglnt_dynclk_enable(clk_hw);
+
+	printk(KERN_INFO "Digilent dynamic clock rate set to %lu (kHz) with parent clock %lu (khz)\r\n", rate, parent_rate);
+
+	return 0;
+}
+
+static long dglnt_dynclk_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	struct dglnt_dynclk_mode clkMode;
+
+	dglnt_dynclk_find_mode(((rate + 100) / 200), ((*parent_rate) + 500) / 1000, &clkMode);
+
+	return (clkMode.freq * 200);
+}
+
+static unsigned long dglnt_dynclk_recalc_rate(struct clk_hw *clk_hw, unsigned long parent_rate)
+{
+	struct dglnt_dynclk *dglnt_dynclk = clk_hw_to_dglnt_dynclk(clk_hw);
+
+	return dglnt_dynclk->freq;
+}
+
+static const struct clk_ops dglnt_dynclk_ops =
+{
+	.recalc_rate	= dglnt_dynclk_recalc_rate,
+	.round_rate	= dglnt_dynclk_round_rate,
+	.set_rate	= dglnt_dynclk_set_rate,
+	.enable		= dglnt_dynclk_enable,
+	.disable	= dglnt_dynclk_disable,
+};
+
+
+static struct of_device_id clk_dglnt_dynclk_of_match[] =
+{
+	{ .compatible = "xlnx,axi-dynclk-1.2", "digilent,axi-dynclk"},
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, clk_dglnt_dynclk_of_match);
+
+
+static int clk_dglnt_dynclk_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+	struct dglnt_dynclk *dglnt_dynclk;
+	struct clk_init_data init;
+	const char *parent_name;
+	const char *clk_name;
+	struct resource *mem;
+	struct clk *clk;
+
+	int rc;	
+
+	if (!pdev->dev.of_node)
+	{
+		return -ENODEV;
+	}
+
+	id = of_match_node(clk_dglnt_dynclk_of_match, pdev->dev.of_node);
+	if (!id)
+	{
+		return -ENODEV;
+	}
+
+	dglnt_dynclk = devm_kzalloc(&pdev->dev, sizeof(*dglnt_dynclk), GFP_KERNEL);
+	if (!dglnt_dynclk)
+	{
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, dglnt_dynclk);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dglnt_dynclk->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(dglnt_dynclk->base))
+	{
+		return PTR_ERR(dglnt_dynclk->base);
+	}
+
+	parent_name = of_clk_get_parent_name(pdev->dev.of_node, 0);
+	if (!parent_name)
+	{
+		return -EINVAL;
+	}
+
+	clk_name = pdev->dev.of_node->name;
+	rc = of_property_read_string(pdev->dev.of_node, "clock-output-names", &clk_name);
+	if (rc)
+	{
+		dev_err(&pdev->dev, "error getting clock output name %d\r\n", rc);
+	}
+
+	init.name = clk_name;
+	init.ops = &dglnt_dynclk_ops;
+	init.flags = 0;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	dglnt_dynclk->freq = 0;
+	dglnt_dynclk_disable(&dglnt_dynclk->clk_hw);
+
+	dglnt_dynclk->clk_hw.init = &init;
+	/* Revert to deprecated driver to make it work with Linux FB Emulator */
+//	clk = devm_clk_hw_register(&pdev->dev, &dglnt_dynclk->clk_hw);
+	clk = devm_clk_register(&pdev->dev, &dglnt_dynclk->clk_hw);
+	if (IS_ERR(clk))
+	{
+		return PTR_ERR(clk);
+	}
+
+	/* Revert to deprecated driver to make it work with Linux FB Emulator */
+//	rc = of_clk_add_hw_provider(pdev->dev.of_node, of_clk_hw_simple_get, clk);
+	rc = of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get, clk);
+	dev_info(&pdev->dev, "clk_dglnt_dynclk probed %d\r\n", rc);
+	return rc;
+}
+
+static int clk_dglnt_dynclk_remove(struct platform_device *pdev)
+{
+	of_clk_del_provider(pdev->dev.of_node);
+	return 0;
+}
+
+
+static struct platform_driver clk_dglnt_dynclk_driver =
+{
+	.driver =
+	{
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table	= clk_dglnt_dynclk_of_match,
+	},
+	.probe		= clk_dglnt_dynclk_probe,
+	.remove		= clk_dglnt_dynclk_remove,
+};
+module_platform_driver(clk_dglnt_dynclk_driver);
+
diff --git a/drivers/gpu/drm/xlnx/Kconfig b/drivers/gpu/drm/xlnx/Kconfig
index 4506329fc683..325d9cc65255 100644
--- a/drivers/gpu/drm/xlnx/Kconfig
+++ b/drivers/gpu/drm/xlnx/Kconfig
@@ -80,6 +80,12 @@ config DRM_XLNX_PL_DISP
 	  choose this option if your display pipeline needs one
 	  crtc and plane object with single DMA connected.
 
+config DRM_DIGILENT_ENCODER
+	tristate "Digilent VGA/HDMI DRM Encoder Driver"
+	depends on DRM_XLNX
+	help
+	  DRM slave encoder for Video-out on Digilent boards.
+
 config DRM_XLNX_SDI
 	tristate "Xilinx DRM SDI Subsystem Driver"
 	depends on DRM_XLNX
diff --git a/drivers/gpu/drm/xlnx/Makefile b/drivers/gpu/drm/xlnx/Makefile
index efa236524c8a..7b9ddd56eb93 100644
--- a/drivers/gpu/drm/xlnx/Makefile
+++ b/drivers/gpu/drm/xlnx/Makefile
@@ -19,5 +19,7 @@ obj-$(CONFIG_DRM_XLNX_PL_DISP) += xlnx_pl_disp.o
 xlnx-sdi-objs += xlnx_sdi.o xlnx_sdi_timing.o
 obj-$(CONFIG_DRM_XLNX_SDI) += xlnx-sdi.o
 
+obj-$(CONFIG_DRM_DIGILENT_ENCODER) += digilent_encoder.o
+
 zynqmp-dpsub-objs += zynqmp_disp.o zynqmp_dpsub.o zynqmp_dp.o
 obj-$(CONFIG_DRM_ZYNQMP_DPSUB) += zynqmp-dpsub.o
diff --git a/drivers/gpu/drm/xlnx/digilent_encoder.c b/drivers/gpu/drm/xlnx/digilent_encoder.c
new file mode 100644
index 000000000000..d777bfc9885c
--- /dev/null
+++ b/drivers/gpu/drm/xlnx/digilent_encoder.c
@@ -0,0 +1,534 @@
+/*  digilent-encoder.c - The simplest kernel module.
+
+* Copyright (C) 2013 - 2016 Xilinx, Inc
+*
+*   This program is free software; you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation; either version 2 of the License, or
+*   (at your option) any later version.
+
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License along
+*   with this program. If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_print.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_encoder_slave.h>
+
+#include <video/videomode.h>
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+
+#include <linux/export.h>
+#include <linux/component.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+
+/* BEGIN - Standard module information, edit as appropriate */
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Digilent, Inc.");
+MODULE_DESCRIPTION("digilent_encoder - DRM slave encoder for Video-out on Digilent boards");
+
+#define DRIVER_NAME "digilent_encoder"
+
+/* END - Standard module information, edit as appropriate */
+
+
+/*
+ * Default frame maximums/prefs; can be set in devicetree
+ */
+#define DIGILENT_ENC_REFRESH_RATE		60
+#define DIGILENT_ENC_MAX_FREQ			150000		/* kHz */
+#define DIGILENT_ENC_MAX_H			1920
+#define DIGILENT_ENC_MAX_V			1080
+#define DIGILENT_ENC_PREF_H			1280
+#define DIGILENT_ENC_PREF_V			720
+#define PIXELS_PER_CLK				1
+
+
+struct digilent_encoder 
+{
+	struct drm_encoder	encoder;
+	struct drm_connector	connector;
+	struct drm_display_mode	video_mode;
+	struct device		*dev;
+	struct i2c_adapter	*i2c_bus;
+	bool			i2c_present;
+	struct clk		*pixel_clock;
+	u32			fmax;
+    	u32			hmax;
+	u32			vmax;
+	u32			hpref;
+	u32			vpref;
+	unsigned long		clk_baseaddr;
+};
+
+
+#define encoder_to_digilent_encoder(x) container_of(x, struct digilent_encoder, encoder)
+#define connector_to_digilent_encoder(c) container_of(c, struct digilent_encoder, connector)
+
+
+static enum drm_connector_status digilent_encoder_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct digilent_encoder *digilent = connector_to_digilent_encoder(connector);
+
+	if (digilent->i2c_present)
+	{
+		if (drm_probe_ddc(digilent->i2c_bus))
+		{
+			return connector_status_connected;
+		}
+
+		return connector_status_disconnected;
+	}
+	else
+	{
+		return connector_status_unknown;
+	}
+}
+
+
+static void digilent_encoder_connector_destroy(struct drm_connector *connector)
+{
+	struct digilent_encoder *digilent = connector_to_digilent_encoder(connector);
+	
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+	connector->dev = NULL;
+}
+
+
+static const struct drm_connector_funcs digilent_encoder_connector_funcs =
+{
+//	.dpms				= drm_helper_connector_dpms,
+	.detect				= digilent_encoder_connector_detect,
+	.fill_modes			= drm_helper_probe_single_connector_modes,
+	.destroy			= digilent_encoder_connector_destroy,
+	.atomic_duplicate_state		= drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state		= drm_atomic_helper_connector_destroy_state,
+	.reset				= drm_atomic_helper_connector_reset,
+};
+
+
+static inline digilent_encoder_mode_valid_helper(struct drm_connector *connector,
+						 struct drm_display_mode *mode)
+{
+	struct digilent_encoder *digilent = connector_to_digilent_encoder(connector);
+
+	if (mode && 
+	    !(mode->flags & ((DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK) | DRM_MODE_FLAG_3D_MASK)) &&
+	    (mode->clock <= digilent->fmax) &&
+	    (mode->hdisplay <= digilent->hmax) &&
+	    (mode->vdisplay <= digilent->vmax))
+	{	
+		return MODE_OK;
+	}
+	
+	dev_err(digilent->dev, "mode bad!!!!\r\n");
+
+	return MODE_BAD;
+}
+
+
+static int digilent_encoder_get_modes_helper(struct drm_connector *connector)
+{
+	struct digilent_encoder *digilent = connector_to_digilent_encoder(connector);
+	struct edid *edid;
+	int num_modes = 0;
+
+        if (digilent->i2c_present)
+        {
+                edid = drm_get_edid(connector, digilent->i2c_bus);
+
+                /*
+                 *Other drivers tend to call update edid property after the call to 
+                 *drm_add_edid_modes. If problems with modesetting, this could be why.
+                 */
+                drm_connector_update_edid_property(connector, edid);
+                if (edid) 
+                {
+                        num_modes = drm_add_edid_modes(connector, edid);
+                        kfree(edid);
+                }
+        }
+        else
+        {
+                num_modes = drm_add_modes_noedid(connector, digilent->hmax, digilent->vmax);
+                drm_set_preferred_mode(connector, digilent->hpref, digilent->vpref);
+        }
+        return num_modes;
+}
+
+
+static struct drm_encoder *digilent_encoder_best_encoder_helper(struct drm_connector *connector)
+{
+	struct digilent_encoder *digilent = connector_to_digilent_encoder(connector);
+
+	return &digilent->encoder;
+}
+
+
+static struct drm_connector_helper_funcs digilent_encoder_connector_helper_funcs =
+{
+	.get_modes = digilent_encoder_get_modes_helper,
+	.mode_valid = digilent_encoder_mode_valid_helper,
+	.best_encoder = digilent_encoder_best_encoder_helper,
+};
+
+
+static int digilent_encoder_dynclk_set(struct digilent_encoder *encoder, struct videomode *vm)
+{
+    int ret;
+
+    /* set pixel clock */
+    ret = clk_set_rate(encoder->pixel_clock, vm->pixelclock);
+    if (ret)
+    {
+        DRM_ERROR("failed to set a pixel clock\r\n");
+        return ret;
+    }
+
+    return 0;
+}
+
+
+static void digilent_encoder_atomic_mode_set(struct drm_encoder *encoder,
+					     struct drm_crtc_state *crtc_state,
+					     struct drm_connector_state *connector_state)
+{
+	struct digilent_encoder *digilent = encoder_to_digilent_encoder(encoder);
+	struct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;
+	struct videomode vm;
+
+	u32 sditx_blank, vtc_blank;
+
+	vm.hactive = adjusted_mode->hdisplay / PIXELS_PER_CLK;
+	vm.hfront_porch = (adjusted_mode->hsync_start - adjusted_mode->hdisplay) / PIXELS_PER_CLK;
+	vm.hback_porch = (adjusted_mode->htotal - adjusted_mode->hsync_end) / PIXELS_PER_CLK;
+	vm.hsync_len = (adjusted_mode->hsync_end - adjusted_mode->hsync_start) / PIXELS_PER_CLK;
+	
+	vm.vactive = adjusted_mode->vdisplay;
+	vm.vfront_porch = adjusted_mode->vsync_start - adjusted_mode->vdisplay;
+	vm.vback_porch = adjusted_mode->vtotal - adjusted_mode->vsync_end;
+	vm.vsync_len = adjusted_mode->vsync_end - adjusted_mode->vsync_start;
+    	vm.flags = 0;
+
+	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
+	{
+        	vm.flags |= DISPLAY_FLAGS_INTERLACED;
+	}
+
+	if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
+	{
+		vm.flags |= DISPLAY_FLAGS_HSYNC_LOW;
+	}
+	
+	if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
+	{
+        	vm.flags |= DISPLAY_FLAGS_VSYNC_LOW;
+	}
+
+	do
+	{
+		sditx_blank = (adjusted_mode->hsync_start - adjusted_mode->hdisplay) +
+			      (adjusted_mode->hsync_end - adjusted_mode->hsync_start) +
+			      (adjusted_mode->htotal - adjusted_mode->hsync_end);
+
+		vtc_blank = (vm.hfront_porch + vm.hback_porch + vm.hsync_len) * PIXELS_PER_CLK;
+
+		if (vtc_blank != sditx_blank)
+		{
+			vm.hfront_porch++;
+		}
+	}
+	while (vtc_blank < sditx_blank);
+
+	vm.pixelclock = adjusted_mode->clock * 1000;
+
+//	printk("sdi->video_mode.clock:%d\n", sdi->video_mode.clock);
+//	printk("adjusted_mode->clock:%d\n", adjusted_mode->clock);
+
+//	sdi->video_mode.vdisplay = adjusted_mode->vdisplay;
+//	sdi->video_mode.hdisplay = adjusted_mode->hdisplay;
+//	sdi->video_mode.vrefresh = adjusted_mode->vrefresh;
+//	sdi->video_mode.flags = adjusted_mode->flags;
+
+	drm_mode_copy(&digilent->video_mode, adjusted_mode);
+	
+	digilent_encoder_dynclk_set(digilent, &vm);
+
+	printk(KERN_INFO "digilent_encoder amotic mode set completed\r\n");
+}
+
+
+static void digilent_encoder_enable(struct drm_encoder *encoder)
+{
+
+}
+
+static void digilent_encoder_disable(struct drm_encoder *encoder)
+{
+
+}
+
+
+static const struct drm_encoder_helper_funcs digilent_encoder_helper_funcs =
+{
+	.atomic_mode_set = digilent_encoder_atomic_mode_set,
+	.enable = digilent_encoder_enable,
+	.disable = digilent_encoder_disable,
+};
+
+
+static const struct drm_encoder_funcs digilent_encoder_funcs =
+{
+    .destroy = drm_encoder_cleanup,
+};
+
+
+static int digilent_encoder_create_connector(struct drm_encoder *encoder)
+{
+	struct digilent_encoder *digilent = encoder_to_digilent_encoder(encoder);
+	struct drm_connector *connector = &digilent->connector;
+	int rc;
+
+	connector->polled = DRM_CONNECTOR_POLL_HPD;
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;
+
+	rc = drm_connector_init(encoder->dev, connector, &digilent_encoder_connector_funcs, DRM_MODE_CONNECTOR_HDMIA);
+	if (rc)
+	{
+		dev_err(digilent->dev, "Failed to initialize connector with drm\r\n");
+		return rc;
+	}
+
+	drm_connector_helper_add(connector, &digilent_encoder_connector_helper_funcs);
+	
+	rc = drm_connector_register(connector);
+	if (rc)
+	{
+        	dev_err(digilent->dev, "Failed to register the connector (ret = %d)\r\n", rc);
+        	return rc;
+	}
+	
+	rc = drm_connector_attach_encoder(connector, encoder);
+	if (rc)
+	{
+		dev_err(digilent->dev, "Failed to attach encoder to connector (ret = %d)\r\n", rc);
+		return rc;
+	}
+	
+	return 0;
+}
+
+
+static int digilent_encoder_bind(struct device *dev, struct device *master, void *data)
+{
+	struct digilent_encoder *digilent = dev_get_drvdata(dev);
+	struct drm_encoder *encoder = &digilent->encoder;
+	struct drm_device *drm_dev = data;
+	int rc;
+
+	/**
+	 * TODO: The possible CRTCs are 1 now as per current implementation of
+	 * HDMI driver. DRM framework can support more than one CRTCs and
+	 * HDMI driver can be enchanced for that.
+	 **/
+	encoder->possible_crtcs = 1;
+	drm_encoder_init(drm_dev, encoder, &digilent_encoder_funcs, DRM_MODE_ENCODER_TMDS, NULL);
+	drm_encoder_helper_add(encoder, &digilent_encoder_helper_funcs);
+	
+	rc = digilent_encoder_create_connector(encoder);
+	if (rc)
+	{
+		dev_err(digilent->dev, "fail creating connect, rc = %d\r\n", rc);
+		drm_encoder_cleanup(encoder);
+	}
+	
+	return rc;
+}
+
+
+static void digilent_encoder_unbind(struct device *dev, struct device *master, void *data)
+{
+    struct digilent_encoder *digilent = dev_get_drvdata(dev);
+
+    drm_encoder_cleanup(&digilent->encoder);
+    drm_connector_cleanup(&digilent->connector);
+}
+
+
+static const struct component_ops digilent_encoder_component_ops =
+{
+	.bind = digilent_encoder_bind,
+	.unbind = digilent_encoder_unbind,
+};
+
+
+static int digilent_encoder_probe(struct platform_device *pdev)
+{
+	struct digilent_encoder *digilent;
+	struct device_node *sub_node;
+	u32 clk_base_address;
+	int rc;
+
+	digilent = devm_kzalloc(&pdev->dev, sizeof(*digilent), GFP_KERNEL);
+	if (!digilent)
+	{
+		return -ENOMEM;
+	}
+	
+	digilent->dev = &pdev->dev;
+	platform_set_drvdata(pdev, digilent);
+
+	rc = of_property_read_u32(pdev->dev.of_node, "digilent,clk-baseaddr", &clk_base_address);
+	if (rc)
+	{
+		dev_info(digilent->dev, "failed to get the clk base address\r\n");
+	}
+	else
+	{
+		digilent->clk_baseaddr = clk_base_address;
+		dev_info(digilent->dev, "clock base address %#08lx\r\n", digilent->clk_baseaddr);
+	}
+
+	digilent->pixel_clock = devm_clk_get(digilent->dev, "pixel-clk");
+	if (IS_ERR(digilent->pixel_clock))
+	{
+		if (PTR_ERR(digilent->pixel_clock) == -EPROBE_DEFER)
+		{
+			rc = PTR_ERR(digilent->pixel_clock);
+			dev_info(digilent->dev,"failed to get pixel clock\r\n");
+		}
+		else
+		{
+			dev_info(digilent->dev,"failed to get pixel clock\r\n");
+			digilent->pixel_clock = NULL;
+		}
+	}
+	
+	/* get i2c adapter for edid */
+	digilent->i2c_present = false;
+
+	sub_node = of_parse_phandle(pdev->dev.of_node, "digilent,edid-i2c", 0);
+	if (sub_node)
+	{
+		digilent->i2c_bus = of_find_i2c_adapter_by_node(sub_node);
+		if (!digilent->i2c_bus)
+		{
+			dev_info(&pdev->dev, "failed to get the edid i2c adapter, using default modes\r\n");
+		}
+		else
+		{
+			dev_info(&pdev->dev, "edid-i2c found\r\n");
+			digilent->i2c_present = true;
+		}
+		of_node_put(sub_node);
+	}
+
+        rc = of_property_read_u32(pdev->dev.of_node, "digilent,fmax", &digilent->fmax);
+        if (rc < 0)
+	{
+                digilent->fmax = DIGILENT_ENC_MAX_FREQ;
+                dev_info(&pdev->dev, "No max frequency in DT, using default %dkHz\r\n", DIGILENT_ENC_MAX_FREQ);
+        }
+
+        rc = of_property_read_u32(pdev->dev.of_node, "digilent,hmax", &digilent->hmax);
+        if (rc < 0)
+	{
+                digilent->hmax = DIGILENT_ENC_MAX_H;
+                dev_info(&pdev->dev, "No max horizontal width in DT, using default %d\r\n", DIGILENT_ENC_MAX_H);
+        }
+
+        rc = of_property_read_u32(pdev->dev.of_node, "digilent,vmax", &digilent->vmax);
+        if (rc < 0)
+	{
+                digilent->vmax = DIGILENT_ENC_MAX_V;
+                dev_info(&pdev->dev, "No max vertical height in DT, using default %d\r\n", DIGILENT_ENC_MAX_V);
+        }
+
+        rc = of_property_read_u32(pdev->dev.of_node, "digilent,hpref", &digilent->hpref);
+        if (rc < 0)
+	{
+                digilent->hpref = DIGILENT_ENC_PREF_H;
+                if (!digilent->i2c_present)
+		{
+                        dev_info(&pdev->dev, "No pref horizontal width in DT, using default %d\r\n", DIGILENT_ENC_PREF_H);
+		}
+        }
+
+        rc = of_property_read_u32(pdev->dev.of_node, "digilent,vpref", &digilent->vpref);
+        if (rc < 0)
+	{
+                digilent->vpref = DIGILENT_ENC_PREF_V;
+                if (!digilent->i2c_present)
+		{
+                        dev_info(&pdev->dev, "No pref vertical height in DT, using default %d\n", DIGILENT_ENC_PREF_V);
+		}
+        }
+	
+	pdev->dev.platform_data = &digilent->video_mode;
+	dev_info(&pdev->dev, "set default display resolution to %dx%d, max frequency %d\r\n", digilent->hpref, digilent->vpref, digilent->fmax);
+
+	rc = component_add(digilent->dev, &digilent_encoder_component_ops);
+
+	dev_info(&pdev->dev, "digilent_encoder module probe returns %d\r\n", rc);
+
+	return rc;
+}
+
+
+static int digilent_encoder_remove(struct platform_device *pdev)
+{
+	struct digilent_encoder *digilent = platform_get_drvdata(pdev);
+
+	component_del(digilent->dev, &digilent_encoder_component_ops);
+	
+	return 0;
+}
+
+
+static struct of_device_id digilent_encoder_of_match[] =
+{
+	{ .compatible = "digilent,drm-encoder"},
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, digilent_encoder_of_match);
+
+
+static struct platform_driver digilent_encoder_driver =
+{
+	.driver =
+	{
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table	= digilent_encoder_of_match,
+	},
+	.probe		= digilent_encoder_probe,
+	.remove		= digilent_encoder_remove,
+};
+module_platform_driver(digilent_encoder_driver);
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 1e70e838530e..b1fa78a4170f 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2016,6 +2016,16 @@ config FB_XILINX
 	  framebuffer. ML300 carries a 640*480 LCD display on the board,
 	  ML403 uses a standard DB15 VGA connector.
 
+config FB_VDMA
+	tristate "MYIR VDMA frame buffer support"
+	depends on FB && (ARCH_ZYNQ || ARCH_ZYNQMP)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select XILINX_AXIVDMA
+	---help---
+	  Include support for the VDMA LCD reference design framebuffer.
+
 config FB_GOLDFISH
 	tristate "Goldfish Framebuffer"
 	depends on FB
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index aa6352798cf4..3939998854eb 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -110,6 +110,7 @@ obj-$(CONFIG_FB_SM501)            += sm501fb.o
 obj-$(CONFIG_FB_UDL)		  += udlfb.o
 obj-$(CONFIG_FB_SMSCUFX)	  += smscufx.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
+obj-$(CONFIG_FB_VDMA)		  += vdmafb.o
 obj-$(CONFIG_FB_SH_MOBILE_LCDC)	  += sh_mobile_lcdcfb.o
 obj-$(CONFIG_FB_OMAP)             += omap/
 obj-y                             += omap2/
diff --git a/drivers/video/fbdev/logicvc.h b/drivers/video/fbdev/logicvc.h
new file mode 100644
index 000000000000..382a5d1f76c7
--- /dev/null
+++ b/drivers/video/fbdev/logicvc.h
@@ -0,0 +1,211 @@
+/*
+ * Xylon logiCVC IP core v2.05c definitions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __LOGICVC_H__
+#define __LOGICVC_H__
+
+/* All logiCVC registers are 32 bit registers */
+/* All logiCVC registers are at 8 byte distance */
+#define LOGICVC_REG_DIST_USED      8
+/* R_HSY_FP */
+#define LOGICVC_SHSY_FP_ROFF      (0  * LOGICVC_REG_DIST_USED)
+/* R_HSY */
+#define LOGICVC_SHSY_ROFF         (1  * LOGICVC_REG_DIST_USED)
+/* R_HSY_BP */
+#define LOGICVC_SHSY_BP_ROFF      (2  * LOGICVC_REG_DIST_USED)
+/* R_HSY_RES */
+#define SHSY_RES_ROFF             0x54
+/* R_VSY_FP */
+#define LOGICVC_SVSY_FP_ROFF      (4  * LOGICVC_REG_DIST_USED)
+/* R_VSY */
+#define LOGICVC_SVSY_ROFF         (5  * LOGICVC_REG_DIST_USED)
+/* R_VSY_BP */
+#define LOGICVC_SVSY_BP_ROFF      (6  * LOGICVC_REG_DIST_USED)
+/* R_VSY_RES */
+#define SVSY_RES_ROFF             0x50
+/* R_CTRL */
+#define LOGICVC_SCTRL_ROFF        (8  * LOGICVC_REG_DIST_USED)
+/* R_DTYPE */
+#define LOGICVC_SDTYPE_ROFF       (9  * LOGICVC_REG_DIST_USED)
+/* R_BACKGROUND */
+#define LOGICVC_BACKCOL_ROFF      (10 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_VBUFF */
+#define LOGICVC_DOUBLE_VBUFF_ROFF (11 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_CLUT */
+#define LOGICVC_DOUBLE_CLUT_ROFF  (12 * LOGICVC_REG_DIST_USED)
+/* R_INT_STAT */
+#define LOGICVC_INT_STAT_ROFF     (13 * LOGICVC_REG_DIST_USED)
+/* R_INT_MASK */
+#define LOGICVC_INT_MASK_ROFF     (14 * LOGICVC_REG_DIST_USED)
+/* R_PWRCTRL */
+#define LOGICVC_SPWRCTRL_ROFF     (15 * LOGICVC_REG_DIST_USED)
+/* R_IPVER */
+#define LOGICVC_IPVER_ROFF        (18 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC layer registers base and distance between the layers */
+/* distance between groups of layer registers */
+#define LOGICVC_LAYER_DISTANCE   (16  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 0 registers */
+#define LOGICVC_LAYER0_BASE_ROFF (32  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 1 registers */
+#define LOGICVC_LAYER1_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 1)
+/* offset to the beginning of layer 2 registers */
+#define LOGICVC_LAYER2_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 2)
+/* offset to the beginning of layer 3 registers */
+#define LOGICVC_LAYER3_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 3)
+/* offset to the beginning of layer 4 registers */
+#define LOGICVC_LAYER4_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 4)
+
+/* logiCVC layer registers offsets (common for each layer) */
+/*  LH_OFFSET */
+#define LOGICVC_LAYER_HOR_OFF_ROFF (0 * LOGICVC_REG_DIST_USED)
+/*  LV_OFFSET */
+#define LOGICVC_LAYER_VER_OFF_ROFF (1 * LOGICVC_REG_DIST_USED)
+/*  LH_POSITION */
+#define LOGICVC_LAYER_HOR_POS_ROFF (2 * LOGICVC_REG_DIST_USED)
+/*  LV_POSITION */
+#define LOGICVC_LAYER_VER_POS_ROFF (3 * LOGICVC_REG_DIST_USED)
+/*  LH_WIDTH */
+#define LOGICVC_LAYER_WIDTH_ROFF   (4 * LOGICVC_REG_DIST_USED)
+/*  LV_HEIGHT */
+#define LOGICVC_LAYER_HEIGHT_ROFF  (5 * LOGICVC_REG_DIST_USED)
+/*  ALPHA */
+#define LOGICVC_LAYER_ALPHA_ROFF   (6 * LOGICVC_REG_DIST_USED)
+/*  CTRL */
+#define LOGICVC_LAYER_CTRL_ROFF    (7 * LOGICVC_REG_DIST_USED)
+/*  TRANSPARENT */
+#define LOGICVC_LAYER_TRANSP_ROFF  (8 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC interrupt bits */
+#define LOGICVC_L0_VBUFF_SW_INT   0x01
+#define LOGICVC_L1_VBUFF_SW_INT   0x02
+#define LOGICVC_L2_VBUFF_SW_INT   0x04
+#define LOGICVC_L3_VBUFF_SW_INT   0x08
+#define LOGICVC_L4_VBUFF_SW_INT   0x10
+#define LOGICVC_V_SYNC_INT        0x20
+#define LOGICVC_E_VIDEO_VALID_INT 0x40
+#define LOGICVC_L0_CLUT_SW_INT    0x100
+#define LOGICVC_L1_CLUT_SW_INT    0x200
+#define LOGICVC_L2_CLUT_SW_INT    0x400
+#define LOGICVC_L3_CLUT_SW_INT    0x800
+#define LOGICVC_L4_CLUT_SW_INT    0x1000
+
+/* logiCVC layer base offsets */
+#define LOGICVC_LAYER_OFFSET      0x80
+#define LOGICVC_LAYER_BASE_OFFSET 0x100
+#define LOGICVC_LAYER_0_OFFSET    0
+#define LOGICVC_LAYER_1_OFFSET \
+	(LOGICVC_LAYER_0_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_2_OFFSET \
+	(LOGICVC_LAYER_1_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_3_OFFSET \
+	(LOGICVC_LAYER_2_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_4_OFFSET \
+	(LOGICVC_LAYER_3_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_BASE_END    0x338
+
+/* logiCVC layer CLUT base offsets */
+#define LOGICVC_CLUT_OFFSET           0x800
+#define LOGICVC_CLUT_BASE_OFFSET      0x1000
+#define LOGICVC_CLUT_L0_CLUT_0_OFFSET 0
+#define LOGICVC_CLUT_L0_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L0_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L1_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L0_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L1_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L1_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L2_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L1_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L2_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L2_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L3_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L2_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L3_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L3_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L4_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L3_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L4_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L4_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_REGISTER_SIZE    8
+#define LOGICVC_CLUT_0_INDEX_OFFSET   2
+#define LOGICVC_CLUT_1_INDEX_OFFSET   1
+
+/* logiCVC register and CLUT base offsets */
+#define LOGICVC_GENERAL_REGISTERS_RANGE 0x100
+#define LOGICVC_REGISTERS_RANGE         0x6000
+
+/* logiCVC register initial values */
+#define CTRL_REG_INIT 0x001F
+#define SD_REG_INIT   0
+
+/* logiCVC display power signals */
+#define LOGICVC_EN_BLIGHT_MSK 0x01
+#define LOGICVC_EN_VDD_MSK    0x02
+#define LOGICVC_EN_VEE_MSK    0x04
+#define LOGICVC_V_EN_MSK      0x08
+
+/* logiCVC various definitions */
+#define LOGICVC_PIX_DATA_INVERT        0x80
+#define LOGICVC_PIX_ACT_HIGH           0x100
+#define LOGICVC_LAYER_ON               0x01
+#define LOGICVC_SWAP_RB                0x10
+#define LOGICVC_MAX_LAYERS             5
+#define LOGICVC_MAX_LAYER_BUFFERS      3
+#define LOGICVC_MIN_XRES               64
+#define LOGICVC_MAX_XRES               2048
+#define LOGICVC_MIN_VRES               1
+#define LOGICVC_MAX_VRES               2048
+#define LOGICVC_MAX_LINES              4096
+#define LOGICVC_CLUT_SIZE              256
+#define TRANSPARENT_COLOR_8BPP         0x25       /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_16 0xF813     /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_24 0x00FF009C /* dummy */
+#define TRANSPARENT_COLOR_16BPP        0xF813     /* dummy */
+#define TRANSPARENT_COLOR_24BPP        0x00FF009C /* dummy */
+#define BACKGROUND_COLOR               0x00000000
+
+#define LOGICVC_READABLE_REGS 0x01
+
+enum xylonfb_layer_type {
+	LOGICVC_RGB_LAYER = 0,
+	LOGICVC_YCBCR_LAYER,
+	LOGICVC_ALPHA_LAYER
+};
+
+enum xylonfb_alpha_format {
+	LOGICVC_LAYER_ALPHA = 0,
+	LOGICVC_PIXEL_ALPHA,
+	LOGICVC_CLUT_16BPP_ALPHA,
+	LOGICVC_CLUT_32BPP_ALPHA
+};
+
+enum xylonfb_display_interface {
+	LOGICVC_DI_PARALLEL = 0,
+	LOGICVC_DI_ITU656,
+	LOGICVC_DI_LVDS_4bit,
+	LOGICVC_DI_CAMERA_LINK_4bit,
+	LOGICVC_DI_LVDS_3bit,
+	LOGICVC_DI_DVI
+};
+
+enum xylonfb_display_color_space {
+	LOGICVC_DCS_RGB = 0,
+	LOGICVC_DCS_YUV422,
+	LOGICVC_DCS_YUV444
+};
+
+#endif /* __LOGICVC_H__ */
diff --git a/drivers/video/fbdev/vdmafb.c b/drivers/video/fbdev/vdmafb.c
new file mode 100644
index 000000000000..7dfa33cc2846
--- /dev/null
+++ b/drivers/video/fbdev/vdmafb.c
@@ -0,0 +1,1075 @@
+/*
+ * MYIR AXI VDMA frame buffer driver
+ * Based on: vdmafb.c
+ *
+ * Copyright (C) 2019 MYIR tech
+ * Author: calvin <calvin.liu@myirtech.com>
+ *
+ * Licensed under the GPL-2.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/dma/xilinx_dma.h>
+
+#include "vdmafb.h"
+
+static char *fmrfb_mode_option;
+
+struct vdmafb_dev
+{
+	struct fb_info info;
+	/* Physical and virtual addresses of framebuffer */
+	phys_addr_t fb_phys;
+	void __iomem *fb_virt;
+	/* VDMA handle */
+	struct dma_chan *dma;
+	struct dma_interleaved_template *dma_template;
+	/* Palette data */
+	u32 pseudo_palette[16];
+};
+
+static int vdmafb_parse_hw_info(struct device_node *np, struct vdmafb_init_data *init_data)
+{
+	u32 const *prop;
+	int size;
+
+	prop = of_get_property(np, "fmr,display-interface", &size);
+	if (!prop)
+	{
+		pr_err("Error fmrfb getting display interface\n");
+		return -EINVAL;
+	}
+	init_data->display_interface_type = be32_to_cpup(prop) << 4;
+
+	prop = of_get_property(np, "fmr,display-color-space", &size);
+	if (!prop)
+	{
+		pr_err("Error fmrfb getting display color space\n");
+		return -EINVAL;
+	}
+	init_data->display_interface_type |= be32_to_cpup(prop);
+
+	prop = of_get_property(np, "fmr,vtc-baseaddr", &size);
+	if (!prop)
+	{
+		pr_warn("Error fmrfb getting vtc baseaddr\n");
+	}
+	else
+	{
+		if (be32_to_cpup(prop))
+			init_data->vtc_baseaddr = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "fmr,vtc-size", &size);
+	if (!prop)
+	{
+		pr_warn("Error fmrfb getting vtc size\n");
+	}
+	else
+	{
+		if (be32_to_cpup(prop))
+			init_data->vtc_size = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "fmr,clk-en", &size);
+	if (!prop)
+	{
+		init_data->clk_en = 0;
+	}
+	else
+	{
+		init_data->clk_en = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "fmr,clk-baseaddr", &size);
+	if (!prop)
+	{
+		pr_warn("Error fmrfb getting clk baseaddr\n");
+	}
+	else
+	{
+		if (be32_to_cpup(prop))
+			init_data->clk_baseaddr = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "fmr,clk-size", &size);
+	if (!prop)
+	{
+		pr_warn("Error fmrfb getting clk size\n");
+	}
+	else
+	{
+		if (be32_to_cpup(prop))
+			init_data->clk_size = be32_to_cpup(prop);
+	}
+
+	return 0;
+}
+
+static void vdmafb_set_ctrl_reg(struct vdmafb_init_data *init_data, unsigned long pix_data_invert, unsigned long pix_clk_act_high)
+{
+	u32 sync = init_data->vmode_data.fb_vmode.sync;
+	u32 ctrl = CTRL_REG_INIT;
+
+	/* FB_SYNC_HOR_HIGH_ACT */
+	if (!(sync & (1 << 0)))
+	{
+		ctrl &= (~(1 << 1));
+	}
+	/* FB_SYNC_VERT_HIGH_ACT */
+	if (!(sync & (1 << 1)))
+	{
+		ctrl &= (~(1 << 3));
+	}
+	if (pix_data_invert)
+	{
+		ctrl |= LOGICVC_PIX_DATA_INVERT;
+	}
+	if (pix_clk_act_high)
+	{
+		ctrl |= LOGICVC_PIX_ACT_HIGH;
+	}
+
+	init_data->vmode_data.ctrl_reg = ctrl;
+}
+
+static int vdmafb_parse_vmode_info(struct device_node *np, struct vdmafb_init_data *init_data)
+{
+	struct device_node *dn, *vmode_np;
+	u32 const *prop;
+	char *c;
+	unsigned long pix_data_invert, pix_clk_act_high;
+	int size, tmp;
+
+	vmode_np = NULL;
+	init_data->vmode_data.fb_vmode.refresh = 60;
+	init_data->active_layer = 0;
+	init_data->vmode_params_set = false;
+
+	prop = of_get_property(np, "active-layer", &size);
+	if (prop)
+	{
+		tmp = be32_to_cpup(prop);
+		init_data->active_layer = (unsigned char)tmp;
+	}
+	else
+	{
+		pr_info("fmrfb setting default layer to %d\n", init_data->active_layer);
+	}
+
+	prop = of_get_property(np, "videomode", &size);
+	if (prop)
+	{
+		if (strlen((char *)prop) <= VMODE_NAME_SZ)
+		{
+			dn = NULL;
+			dn = of_find_node_by_name(NULL, "fmr-video-params");
+			if (dn)
+			{
+				strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+				vmode_np = of_find_node_by_name(dn, init_data->vmode_data.fb_vmode_name);
+				c = strchr((char *)prop, '_');
+				if (c)
+				{
+					*c = 0;
+				}
+				strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			}
+			else
+			{
+				strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			}
+			of_node_put(dn);
+		}
+		else
+		{
+			pr_err("Error videomode name to long\n");
+		}
+		if (vmode_np)
+		{
+			prop = of_get_property(vmode_np, "refresh", &size);
+			if (!prop)
+			{
+				pr_err("Error getting refresh rate\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.refresh = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "xres", &size);
+			if (!prop)
+			{
+				pr_err("Error getting xres\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.xres = be32_to_cpup(prop);
+			}
+			prop = of_get_property(vmode_np, "yres", &size);
+			if (!prop)
+			{
+				pr_err("Error getting yres\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.yres = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "pixclock-khz", &size);
+			if (!prop)
+			{
+				pr_err("Error getting pixclock-khz\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.pixclock = KHZ2PICOS(be32_to_cpup(prop));
+			}
+
+			prop = of_get_property(vmode_np, "left-margin", &size);
+			if (!prop)
+			{
+				pr_err("Error getting left-margin\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.left_margin = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "right-margin", &size);
+			if (!prop)
+			{
+				pr_err("Error getting right-margin\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.right_margin = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "upper-margin", &size);
+			if (!prop)
+			{
+				pr_err("Error getting upper-margin\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.upper_margin = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "lower-margin", &size);
+			if (!prop)
+			{
+				pr_err("Error getting lower-margin\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.lower_margin = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "hsync-len", &size);
+			if (!prop)
+			{
+				pr_err("Error getting hsync-len\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.hsync_len = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "vsync-len", &size);
+			if (!prop)
+			{
+				pr_err("Error getting vsync-len\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.vsync_len = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "sync", &size);
+			if (!prop)
+			{
+				pr_err("Error getting sync\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.sync = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "vmode", &size);
+			if (!prop)
+			{
+				pr_err("Error getting vmode\n");
+			}
+			else
+			{
+				init_data->vmode_data.fb_vmode.vmode = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-clk0L", &size);
+			if (!prop)
+			{
+				pr_err("Error getting clk0L\n");
+			}
+			else
+			{
+				init_data->clkreg.clk0L = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-clkFBL", &size);
+			if (!prop)
+			{
+				pr_err("Error getting clkFBL\n");
+			}
+			else
+			{
+				init_data->clkreg.clkFBL = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-clkFBH_clk0H", &size);
+			if (!prop)
+			{
+				pr_err("Error getting clkFBH_clk0H\n");
+			}
+			else
+			{
+				init_data->clkreg.clkFBH_clk0H = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-divclk", &size);
+			if (!prop)
+			{
+				pr_err("Error getting divclk\n");
+			}
+			else
+			{
+				init_data->clkreg.divclk = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-lockL", &size);
+			if (!prop)
+			{
+				pr_err("Error getting lockL\n");
+			}
+			else
+			{
+				init_data->clkreg.lockL = be32_to_cpup(prop);
+			}
+
+			prop = of_get_property(vmode_np, "dynclk-fltr_lockH", &size);
+			if (!prop)
+			{
+				pr_err("Error getting fltr_lockH\n");
+			}
+			else
+			{
+				init_data->clkreg.fltr_lockH = be32_to_cpup(prop);
+			}
+
+			init_data->vmode_params_set = true;
+		}
+	}
+	else
+	{
+		pr_info("fmrfb using default driver video mode\n");
+	}
+
+	vdmafb_set_ctrl_reg(init_data, pix_data_invert, pix_clk_act_high);
+
+	return 0;
+}
+
+static void vdmafb_init_vtc_regs(struct vdmafb_layer_data *ld, struct vdmafb_common_data *cd)
+{
+	int h_pixels, v_lines;
+
+	// printk("0x00=%0x\n\r", readl(ld->vtc_base_virt + 0x00));
+	// printk("0x60=%0x\n\r", readl(ld->vtc_base_virt + 0x60));
+	// printk("0x68=%0x\n\r", readl(ld->vtc_base_virt + 0x68));
+	// printk("0x6c=%0x\n\r", readl(ld->vtc_base_virt + 0x6c));
+	// printk("0x70=%0x\n\r", readl(ld->vtc_base_virt + 0x70));
+	// printk("0x74=%0x\n\r", readl(ld->vtc_base_virt + 0x74));
+	// printk("0x78=%0x\n\r", readl(ld->vtc_base_virt + 0x78));
+	// printk("0x7c=%0x\n\r", readl(ld->vtc_base_virt + 0x7c));
+	// printk("0x80=%0x\n\r", readl(ld->vtc_base_virt + 0x80));
+	// printk("0x84=%0x\n\r", readl(ld->vtc_base_virt + 0x84));
+	// printk("0x88=%0x\n\r", readl(ld->vtc_base_virt + 0x88));
+	// printk("0x8c=%0x\n\r", readl(ld->vtc_base_virt + 0x8c));
+	// printk("0x90=%0x\n\r", readl(ld->vtc_base_virt + 0x90));
+
+	writel(0x3F7EF06, ld->vtc_base_virt);
+
+	h_pixels = cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.hsync_len + cd->vmode_data_current.fb_vmode.left_margin + cd->vmode_data_current.fb_vmode.right_margin;
+
+	v_lines = cd->vmode_data_current.fb_vmode.yres + cd->vmode_data_current.fb_vmode.vsync_len + cd->vmode_data_current.fb_vmode.upper_margin + cd->vmode_data_current.fb_vmode.lower_margin;
+
+	writel((cd->vmode_data_current.fb_vmode.yres << 16) | cd->vmode_data_current.fb_vmode.xres, ld->vtc_base_virt + 0x60);
+	writel(0x0000002, ld->vtc_base_virt + 0x68);
+	writel(0x000007F, ld->vtc_base_virt + 0x6c);
+
+	writel(h_pixels, ld->vtc_base_virt + 0x70);
+	writel((v_lines << 16) | v_lines, ld->vtc_base_virt + 0x74);
+	writel((cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.left_margin) | ((h_pixels - cd->vmode_data_current.fb_vmode.right_margin) << 16), ld->vtc_base_virt + 0x78);
+	writel((cd->vmode_data_current.fb_vmode.xres << 16) | cd->vmode_data_current.fb_vmode.xres, ld->vtc_base_virt + 0x7c);
+
+	writel((cd->vmode_data_current.fb_vmode.yres + cd->vmode_data_current.fb_vmode.lower_margin - 1) | ((cd->vmode_data_current.fb_vmode.yres + cd->vmode_data_current.fb_vmode.lower_margin + cd->vmode_data_current.fb_vmode.vsync_len - 1) << 16), ld->vtc_base_virt + 0x80);
+	writel(((cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.left_margin) << 16) |
+			   (cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.left_margin), ld->vtc_base_virt + 0x84);
+	writel((cd->vmode_data_current.fb_vmode.xres << 16) | cd->vmode_data_current.fb_vmode.xres, ld->vtc_base_virt + 0x88);
+	writel((cd->vmode_data_current.fb_vmode.yres + cd->vmode_data_current.fb_vmode.lower_margin - 1) | ((cd->vmode_data_current.fb_vmode.yres + cd->vmode_data_current.fb_vmode.lower_margin + cd->vmode_data_current.fb_vmode.vsync_len - 1) << 16), ld->vtc_base_virt + 0x8c);
+
+	writel(((cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.left_margin) << 16) | (cd->vmode_data_current.fb_vmode.xres + cd->vmode_data_current.fb_vmode.left_margin), ld->vtc_base_virt + 0x90);
+
+	// writel(0x3F7EF06, ld->vtc_base_virt + 0x00);
+	// writel(0x4380780, ld->vtc_base_virt + 0x60);
+	// writel(0x0000002, ld->vtc_base_virt + 0x68);
+	// writel(0x000007F, ld->vtc_base_virt + 0x6c);
+	// writel(0x0000898, ld->vtc_base_virt + 0x70);
+	// writel(0x4650465, ld->vtc_base_virt + 0x74);
+	// writel(0x80407D8, ld->vtc_base_virt + 0x78);
+	// writel(0x7800780, ld->vtc_base_virt + 0x7c);
+	// writel(0x440043B, ld->vtc_base_virt + 0x80);
+	// writel(0x7D807D8, ld->vtc_base_virt + 0x84);
+	// writel(0x7800780, ld->vtc_base_virt + 0x88);
+	// writel(0x440043B, ld->vtc_base_virt + 0x8c);
+	// writel(0x7D807D8, ld->vtc_base_virt + 0x90);
+
+	// printk("ffffffffffffffffffffffffffffff\n\r");
+
+	// printk("0x00=%0x\n\r", readl(ld->vtc_base_virt + 0x00));
+	// printk("0x60=%0x\n\r", readl(ld->vtc_base_virt + 0x60));
+	// printk("0x68=%0x\n\r", readl(ld->vtc_base_virt + 0x68));
+	// printk("0x6c=%0x\n\r", readl(ld->vtc_base_virt + 0x6c));
+	// printk("0x70=%0x\n\r", readl(ld->vtc_base_virt + 0x70));
+	// printk("0x74=%0x\n\r", readl(ld->vtc_base_virt + 0x74));
+	// printk("0x78=%0x\n\r", readl(ld->vtc_base_virt + 0x78));
+	// printk("0x7c=%0x\n\r", readl(ld->vtc_base_virt + 0x7c));
+	// printk("0x80=%0x\n\r", readl(ld->vtc_base_virt + 0x80));
+	// printk("0x84=%0x\n\r", readl(ld->vtc_base_virt + 0x84));
+	// printk("0x88=%0x\n\r", readl(ld->vtc_base_virt + 0x88));
+	// printk("0x8c=%0x\n\r", readl(ld->vtc_base_virt + 0x8c));
+	// printk("0x90=%0x\n\r", readl(ld->vtc_base_virt + 0x90));
+
+	// printk("\n"
+	// 	   "vdmafb parameters:\n"
+	// 	   "    Horizontal Front Porch: %d pixclks\n"
+	// 	   "    Horizontal Sync:        %d pixclks\n"
+	// 	   "    Horizontal Back Porch:  %d pixclks\n"
+	// 	   "    Vertical Front Porch:   %d pixclks\n"
+	// 	   "    Vertical Sync:          %d pixclks\n"
+	// 	   "    Vertical Back Porch:    %d pixclks\n"
+	// 	   "    Pixel Clock:            %d ps\n"
+	// 	   "    Horizontal Res:         %d\n"
+	// 	   "    Vertical Res:           %d\n"
+	// 	   "\n",
+	// 	   cd->vmode_data_current.fb_vmode.right_margin,
+	// 	   cd->vmode_data_current.fb_vmode.hsync_len,
+	// 	   cd->vmode_data_current.fb_vmode.left_margin,
+	// 	   cd->vmode_data_current.fb_vmode.lower_margin,
+	// 	   cd->vmode_data_current.fb_vmode.vsync_len,
+	// 	   cd->vmode_data_current.fb_vmode.upper_margin,
+	// 	   cd->vmode_data_current.fb_vmode.pixclock,
+	// 	   cd->vmode_data_current.fb_vmode.xres,
+	// 	   cd->vmode_data_current.fb_vmode.yres);
+}
+
+static int vdmafb_setupfb(struct vdmafb_dev *fbdev)
+{
+	struct fb_var_screeninfo *var = &fbdev->info.var;
+	struct dma_async_tx_descriptor *desc;
+	struct dma_interleaved_template *dma_template = fbdev->dma_template;
+	struct xilinx_vdma_config vdma_config;
+	int hsize = var->xres * 4;
+
+	dmaengine_terminate_async(fbdev->dma);
+
+	/* Setup VDMA address etc */
+	memset(&vdma_config, 0, sizeof(vdma_config));
+	vdma_config.park = 1;
+	xilinx_vdma_channel_set_config(fbdev->dma, &vdma_config);
+
+	/*
+	* Interleaved DMA:
+	* Each interleaved frame is a row (hsize) implemented in ONE
+	* chunk (sgl has len 1).
+	* The number of interleaved frames is the number of rows (vsize).
+	* The icg in used to pack data to the HW, so that the buffer len
+	* is fb->piches[0], but the actual size for the hw is somewhat less
+	*/
+	dma_template->dir = DMA_MEM_TO_DEV;
+	dma_template->src_start = fbdev->fb_phys;
+	/* sgl list have just one entry (each interleaved frame have 1 chunk) */
+	dma_template->frame_size = 1;
+	/* the number of interleaved frame, each has the size specified in sgl */
+	dma_template->numf = var->yres;
+	dma_template->src_sgl = 1;
+	dma_template->src_inc = 1;
+	/* vdma IP does not provide any addr to the hdmi IP */
+	dma_template->dst_inc = 0;
+	dma_template->dst_sgl = 0;
+	/* horizontal size */
+	dma_template->sgl[0].size = hsize;
+	/* the vdma driver seems to look at icg, and not src_icg */
+	dma_template->sgl[0].icg = 0; /*  stride - hsize */
+
+	desc = dmaengine_prep_interleaved_dma(fbdev->dma, dma_template, 0);
+	if (!desc)
+	{
+		pr_err("Failed to prepare DMA descriptor\n");
+		return -ENOMEM;
+	}
+	else
+	{
+		dmaengine_submit(desc);
+		dma_async_issue_pending(fbdev->dma);
+	}
+
+	return 0;
+}
+
+// u32 ClkDivider(u32 divide)
+// {
+// 	u32 output = 0;
+// 	u32 highTime = 0;
+// 	u32 lowTime = 0;
+
+// 	if ((divide < 1) || (divide > 128))
+// 		return -1;
+
+// 	if (divide == 1)
+// 		return 0x1041;
+
+// 	highTime = divide / 2;
+// 	if (divide & 0b1) //if divide is odd
+// 	{
+// 		lowTime = highTime + 1;
+// 		output = 1 << CLK_BIT_WEDGE;
+// 	}
+// 	else
+// 	{
+// 		lowTime = highTime;
+// 	}
+
+// 	output |= 0x03F & lowTime;
+// 	output |= 0xFC0 & (highTime << 6);
+// 	return output;
+// }
+
+// u32 ClkCountCalc(u32 divide)
+// {
+// 	u32 output = 0;
+// 	u32 divCalc = 0;
+
+// 	divCalc = ClkDivider(divide);
+// 	if (divCalc == ERR_CLKDIVIDER)
+// 		output = ERR_CLKCOUNTCALC;
+// 	else
+// 		output = (0xFFF & divCalc) | ((divCalc << 10) & 0x00C00000);
+// 	return output;
+// }
+
+// int ClkFindParams(u32 freq, ClkMode *bestPick)
+// {
+// 	u32 bestError = MMCM_FREQ_OUTMAX;
+// 	u32 curError;
+// 	u32 curClkMult;
+// 	u32 curFreq;
+// 	u32 curDiv, curFb, curClkDiv;
+// 	u32 minFb = 0;
+// 	u32 maxFb = 0;
+
+// 	/*
+// 	 * This is necessary because the MMCM actual is generating 5x the desired pixel clock, and that
+// 	 * clock is then run through a BUFR that divides it by 5 to generate the pixel clock. Note this
+// 	 * means the pixel clock is on the Regional clock network, not the global clock network. In the
+// 	 * future if options like these are parameterized in the axi_dynclk core, then this function will
+// 	 * need to change.
+// 	 */
+// 	freq = (freq / 1000) * 5;
+
+// 	bestPick->freq = 0;
+
+// 	/*
+// 	* TODO: replace with a smarter algorithm that doesn't doesn't check every possible combination
+// 	*/
+// 	for (curDiv = 1; curDiv <= 106; curDiv++)
+// 	{
+// 		minFb = curDiv * 6; //This accounts for the 100MHz input and the 600MHz minimum VCO
+// 		maxFb = curDiv * 12; //This accounts for the 100MHz input and the 1200MHz maximum VCO
+// 		if (maxFb > 64)
+// 			maxFb = 64;
+
+// 		curClkMult = (100 / curDiv) / freq; //This multiplier is used to find the best clkDiv value for each FB value
+
+// 		curFb = minFb;
+// 		while (curFb <= maxFb)
+// 		{
+// 			curClkDiv = (u32) ((curClkMult * curFb) + 1);
+
+// 			curFreq = ((100 / curDiv) / curClkDiv) * curFb;
+
+// 			if (curFreq >= freq)
+// 				curError = curFreq - freq;
+// 			else
+// 				curError = freq - curFreq;
+
+// 			if (curError < bestError)
+// 			{
+// 				bestError = curError;
+// 				bestPick->clkdiv = curClkDiv;
+// 				bestPick->fbmult = curFb;
+// 				bestPick->maindiv = curDiv;
+// 				bestPick->freq = curFreq;
+// 			}
+
+// 			curFb++;
+// 		}
+// 	}
+
+// 	/*
+// 	 * We want the ClkMode struct and errors to be based on the desired frequency. Need to check this doesn't introduce
+// 	 * rounding errors.
+// 	 */
+// 	// bestPick->freq = bestPick->freq / 5;
+// 	// bestError = bestError / 5;
+// 	return bestError;
+// }
+
+// u32 ClkFindReg (ClkConfig *regValues, ClkMode *clkParams)
+// {
+// 	if ((clkParams->fbmult < 2) || clkParams->fbmult > 64 )
+// 		return 0;
+
+// 	regValues->clk0L = ClkCountCalc(clkParams->clkdiv);
+// 	if (regValues->clk0L == ERR_CLKCOUNTCALC)
+// 		return 0;
+
+// 	regValues->clkFBL = ClkCountCalc(clkParams->fbmult);
+// 	if (regValues->clkFBL == ERR_CLKCOUNTCALC)
+// 		return 0;
+
+// 	regValues->clkFBH_clk0H = 0;
+
+// 	regValues->divclk = ClkDivider(clkParams->maindiv);
+// 	if (regValues->divclk == ERR_CLKDIVIDER)
+// 		return 0;
+
+// 	regValues->lockL = (u32) (lock_lookup[clkParams->fbmult - 1] & 0xFFFFFFFF);
+
+// 	regValues->fltr_lockH = (u32) ((lock_lookup[clkParams->fbmult - 1] >> 32) & 0x000000FF);
+// 	regValues->fltr_lockH |= ((filter_lookup_low[clkParams->fbmult - 1] << 16) & 0x03FF0000);
+
+// 	return 1;
+// }
+
+void ClkWriteReg (ClkConfig *regValues, u32 dynClkAddr)
+{
+	// printk("regValues->clk0L %04x, regValues->clkFBL %04x, regValues->clkFBH_clk0H %04x, regValues->divclk %04x, regValues->lockL %04x, regValues->fltr_lockH %04x\n", regValues->clk0L, regValues->clkFBL, regValues->clkFBH_clk0H, regValues->divclk, regValues->lockL, regValues->fltr_lockH);
+
+	writel(regValues->clk0L, 		dynClkAddr + OFST_DYNCLK_CLK_L);
+	writel(regValues->clkFBL, 		dynClkAddr + OFST_DYNCLK_FB_L);
+	writel(regValues->clkFBH_clk0H,		dynClkAddr + OFST_DYNCLK_FB_H_CLK_H);
+	writel(regValues->divclk, 		dynClkAddr + OFST_DYNCLK_DIV);
+	writel(regValues->lockL, 		dynClkAddr + OFST_DYNCLK_LOCK_L);
+	writel(regValues->fltr_lockH,		dynClkAddr + OFST_DYNCLK_FLTR_LOCK_H);
+}
+
+void ClkStart(u32 dynClkAddr)
+{
+	writel((1 << BIT_DYNCLK_START),   dynClkAddr + OFST_DYNCLK_CTRL);
+	writel((1 << BIT_DYNCLK_RUNNING), dynClkAddr + OFST_DYNCLK_STATUS);
+	
+	while(!(readl(dynClkAddr + OFST_DYNCLK_STATUS) & (1 << BIT_DYNCLK_RUNNING)))
+	{
+		/* Do nothing. */
+	}
+
+	return;
+}
+
+void ClkStop(u32 dynClkAddr)
+{
+	writel(0,   dynClkAddr + OFST_DYNCLK_CTRL);
+	
+	while((readl(dynClkAddr + OFST_DYNCLK_STATUS) & (1 << BIT_DYNCLK_RUNNING)))
+	{
+		/* Do nothing. */
+	}
+
+	return;
+}
+
+static void vdmafb_init_fix(struct vdmafb_dev *fbdev)
+{
+	struct fb_var_screeninfo *var = &fbdev->info.var;
+	struct fb_fix_screeninfo *fix = &fbdev->info.fix;
+
+	strcpy(fix->id, "vdma-fb");
+	fix->line_length = var->xres * (var->bits_per_pixel / 8);
+	fix->smem_len = fix->line_length * var->yres;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+}
+
+static void vdmafb_init_var(struct vdmafb_dev *fbdev, struct platform_device *pdev, const struct vdmafb_layer_data *ld, const struct vdmafb_common_data *cd)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct fb_var_screeninfo *var = &fbdev->info.var;
+	ClkConfig clkReg;
+	ClkMode clkMode;
+	int ret;
+
+	var->xres = cd->vmode_data_current.fb_vmode.xres;
+	var->yres = cd->vmode_data_current.fb_vmode.yres;
+
+	var->accel_flags = FB_ACCEL_NONE;
+	var->activate = FB_ACTIVATE_NOW;
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+	var->bits_per_pixel = 32;
+	/* Clock settings */
+	var->pixclock = cd->vmode_data_current.fb_vmode.pixclock;//KHZ2PICOS(cd->vmode_data_current.fb_vmode.pixclock * 1000);
+	var->vmode = cd->vmode_data_current.fb_vmode.vmode;
+	/* 32 BPP */
+	var->transp.offset = 24;
+	var->transp.length = 8;
+
+	if(cd->fmrfb_display_interface_type == 1) //RGBA
+	{
+		var->red.offset = 0;
+		var->blue.offset = 16;
+	}
+	else //default mode: BGRA
+	{
+		var->red.offset = 16;
+		var->blue.offset = 0;
+	}
+
+	var->red.length = 8;
+	var->green.offset = 8;
+	var->green.length = 8;
+	var->blue.length = 8;
+
+	/*
+	 * Init VTC Module
+	*/
+	vdmafb_init_vtc_regs(ld, cd);
+}
+
+static int vdmafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+							u_int transp, struct fb_info *info)
+{
+	u32 *pal = info->pseudo_palette;
+	u32 cr = red >> (16 - info->var.red.length);
+	u32 cg = green >> (16 - info->var.green.length);
+	u32 cb = blue >> (16 - info->var.blue.length);
+	u32 value;
+
+	if (regno >= 16)
+	{
+		return -EINVAL;
+	}
+
+	value = (cr << info->var.red.offset) | (cg << info->var.green.offset) | (cb << info->var.blue.offset);
+	if (info->var.transp.length > 0)
+	{
+		u32 mask = (1 << info->var.transp.length) - 1;
+		mask <<= info->var.transp.offset;
+		value |= mask;
+	}
+	pal[regno] = value;
+
+	return 0;
+}
+
+static struct fb_ops vdmafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_setcolreg = vdmafb_setcolreg,
+	.fb_fillrect = sys_fillrect,
+	.fb_copyarea = sys_copyarea,
+	.fb_imageblit = sys_imageblit,
+};
+
+static int vdmafb_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct vdmafb_dev *fbdev;
+	struct vdmafb_common_data *cd;
+	struct vdmafb_layer_data *ld;
+	struct resource *reg_res, *irq_res;
+	int fbsize;
+	unsigned long reg_base_phys;
+	void *vtc_base_virt;
+	unsigned long vtc_baseaddr;
+	int vtc_size;
+	void *clk_base_virt;
+	unsigned long clk_baseaddr;
+	int clk_size;
+	int reg_range, layers, active_layer;
+	int i, rc;
+	struct vdmafb_init_data init_data;
+	ClkConfig clkReg;
+	ClkMode clkMode;
+
+	init_data.pdev = pdev;
+
+	fbdev = devm_kzalloc(&pdev->dev, sizeof(*fbdev), GFP_KERNEL);
+	if (!fbdev)
+	{
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, fbdev);
+
+	fbdev->info.fbops = &vdmafb_ops;
+	fbdev->info.device = &pdev->dev;
+	fbdev->info.par = fbdev;
+
+	fbdev->dma_template = devm_kzalloc(&pdev->dev,
+					   sizeof(struct dma_interleaved_template) + sizeof(struct data_chunk),
+					   GFP_KERNEL);
+	if (!fbdev->dma_template)
+	{
+		return -ENOMEM;
+	}
+
+	reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	// irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if ((!reg_res))
+	{
+		pr_err("Error fmrfb resources\n");
+		return -ENODEV;
+	}
+
+	ret = vdmafb_parse_hw_info(pdev->dev.of_node, &init_data);
+	if (ret)
+	{
+		return ret;
+	}
+
+	vdmafb_parse_vmode_info(pdev->dev.of_node, &init_data);
+
+	layers = init_data.layers;
+	if (layers == 0)
+	{
+		pr_err("Error fmrfb zero layers\n");
+		return -ENODEV;
+	}
+
+	active_layer = init_data.active_layer;
+	if (active_layer >= layers)
+	{
+		pr_err("Error fmrfb default layer: set to 0\n");
+		active_layer = 0;
+	}
+
+	vtc_baseaddr = init_data.vtc_baseaddr;
+	vtc_size = init_data.vtc_size;
+	if (vtc_baseaddr == 0 || vtc_size == 0)
+	{
+		pr_err("Error fmrfb vtc baseaddr\n");
+		return -ENODEV;
+	}
+	
+	clk_baseaddr = init_data.clk_baseaddr;
+	clk_size = init_data.clk_size;
+	if (clk_baseaddr == 0 || clk_size == 0)
+	{
+		pr_err("Error fmrfb clk baseaddr\n");
+		return -ENODEV;
+	}
+
+	cd = kzalloc(sizeof(struct vdmafb_common_data), GFP_KERNEL);
+	if (!cd)
+	{
+		pr_err("Error fmrfb allocating internal data\n");
+		rc = -ENOMEM;
+		goto err_mem;
+	}
+
+	ld = kzalloc(sizeof(struct vdmafb_layer_data), GFP_KERNEL);
+	if (!cd)
+	{
+		pr_err("Error fmrfb allocating layer data\n");
+		rc = -ENOMEM;
+		goto err_mem;
+	}
+
+	cd->vmode_data = init_data.vmode_data;
+	cd->vmode_data_current = init_data.vmode_data;
+	cd->fmrfb_display_interface_type = init_data.display_interface_type;
+
+	reg_base_phys = reg_res->start;
+	reg_range = resource_size(reg_res);
+
+	// reg_base_virt = ioremap_nocache(reg_base_phys, reg_range);
+
+	vtc_base_virt = ioremap_nocache(vtc_baseaddr, vtc_size);
+
+	clk_base_virt = ioremap_nocache(clk_baseaddr, clk_size);
+
+	ld->vtc_base_virt = vtc_base_virt;
+	ld->clk_base_virt = clk_base_virt;
+
+	/*
+	 * Calculate the PLL divider parameters based on the required pixel clock frequency
+	 */
+	// ClkFindParams(cd->vmode_data_current.fb_vmode.pixclock, &clkMode);
+
+	// /*
+	//  * Write to the PLL dynamic configuration registers to configure it with the calculated
+	//  * parameters.
+	//  */
+	// if (!ClkFindReg(&clkReg, &clkMode))
+	// {
+	// 	printk("Error calculating CLK register values\n");
+
+	// 	return -1;
+	// }
+
+	//init dynclk
+	ClkWriteReg(&init_data.clkreg, ld->clk_base_virt);
+	// ClkWriteReg(&clkReg, ld->clk_base_virt);
+
+	/*
+	 * Enable the dynamically generated clock
+    	*/
+    	if(init_data.clk_en)
+   	{
+		ClkStop(ld->clk_base_virt);
+		ClkStart(ld->clk_base_virt);
+	}
+
+	//init vtc
+	vdmafb_init_var(fbdev, pdev, ld, cd);
+	vdmafb_init_fix(fbdev);
+
+	/* Allocate framebuffer memory */
+	fbsize = fbdev->info.fix.smem_len;
+	fbdev->fb_virt = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbsize), &fbdev->fb_phys, GFP_KERNEL);
+	if (!fbdev->fb_virt)
+	{
+		dev_err(&pdev->dev,
+				"Frame buffer memory allocation failed\n");
+		return -ENOMEM;
+	}
+	fbdev->info.fix.smem_start = fbdev->fb_phys;
+	fbdev->info.screen_base = fbdev->fb_virt;
+	fbdev->info.pseudo_palette = fbdev->pseudo_palette;
+
+	pr_debug("%s virt=%p phys=%x size=%d\n", __func__,
+			 fbdev->fb_virt, fbdev->fb_phys, fbsize);
+
+	/* Clear framebuffer */
+	memset_io(fbdev->fb_virt, 0, fbsize);
+
+	fbdev->dma = dma_request_chan(&pdev->dev, "axi_vdma_0");
+	if (IS_ERR_OR_NULL(fbdev->dma))
+	{
+		ret = PTR_ERR(fbdev->dma);
+		dev_err(&pdev->dev, "Failed to allocate DMA channel (%d).\n", ret);
+		goto err_dma_free;
+	}
+
+	/* Setup and enable the framebuffer */
+	vdmafb_setupfb(fbdev);
+
+	ret = fb_alloc_cmap(&fbdev->info.cmap, 256, 0);
+	if (ret)
+	{
+		dev_err(&pdev->dev, "fb_alloc_cmap failed\n");
+	}
+
+	/* Register framebuffer */
+	ret = register_framebuffer(&fbdev->info);
+	if (ret)
+	{
+		dev_err(&pdev->dev, "Framebuffer registration failed\n");
+		goto err_channel_free;
+	}
+
+	dev_info(&pdev->dev, "vdmafb probe ok\r\n");
+
+	return 0;
+
+err_channel_free:
+	dma_release_channel(fbdev->dma);
+err_dma_free:
+	dma_free_coherent(&pdev->dev, PAGE_ALIGN(fbsize), fbdev->fb_virt,
+					  fbdev->fb_phys);
+
+err_mem:
+	if (cd)
+	{
+		kfree(cd->reg_list);
+		kfree(cd);
+	}
+
+	return ret;
+}
+
+static int vdmafb_remove(struct platform_device *pdev)
+{
+	struct vdmafb_dev *fbdev = platform_get_drvdata(pdev);
+
+	unregister_framebuffer(&fbdev->info);
+
+	dma_release_channel(fbdev->dma);
+	dma_free_coherent(&pdev->dev, PAGE_ALIGN(fbdev->info.fix.smem_len), fbdev->fb_virt, fbdev->fb_phys);
+	fb_dealloc_cmap(&fbdev->info.cmap);
+
+	return 0;
+}
+
+
+static struct of_device_id vdmafb_match[] =
+{
+	{
+		.compatible = "myir,vdma-fb",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, vdmafb_match);
+
+static struct platform_driver vdmafb_driver =
+{
+	.probe = vdmafb_probe,
+	.remove = vdmafb_remove,
+	.driver =
+	{
+		.name = "vdmafb_fb",
+		.of_match_table = vdmafb_match,
+	}
+};
+
+
+static int __init vdmafb_init(void)
+{
+	return platform_driver_register(&vdmafb_driver);
+}
+
+
+static void __exit vdmafb_exit(void)
+{
+	platform_driver_unregister(&vdmafb_driver);
+	printk(KERN_INFO "vdmafb_init module exit.\r\n");
+}
+
+module_init(vdmafb_init);
+module_exit(vdmafb_exit);
+
+MODULE_AUTHOR("Calvin <calvin.liu@myirtech.com>");
+MODULE_DESCRIPTION("Driver for VDMA controlled framebuffer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/fbdev/vdmafb.h b/drivers/video/fbdev/vdmafb.h
new file mode 100644
index 000000000000..d4b31bdbfa1a
--- /dev/null
+++ b/drivers/video/fbdev/vdmafb.h
@@ -0,0 +1,343 @@
+#ifndef __VDMAFB_H__
+#define __VDMAFB_H__
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#include "logicvc.h"
+
+/* FmrFB driver flags */
+#define FMRFB_FLAG_RESERVED_0x01 LOGICVC_READABLE_REGS
+#define FMRFB_FLAG_DMA_BUFFER 0x02
+#define FMRFB_FLAG_MEMORY_LE 0x04
+#define FMRFB_FLAG_PIXCLK_VALID 0x08
+#define FMRFB_FLAG_VMODE_INIT 0x10
+#define FMRFB_FLAG_EDID_VMODE 0x20
+#define FMRFB_FLAG_EDID_PRINT 0x40
+#define FMRFB_FLAG_DEFAULT_VMODE_SET 0x80
+#define FMRFB_FLAG_VMODE_SET 0x100
+
+/*
+	Following flags must be updated in fmrfb miscellaneous
+	header files for every functionality specifically
+*/
+#define FMRFB_FLAG_MISC_ADV7511 0x1000
+#define FMRFB_FLAG_ADV7511_SKIP 0x2000
+#define FMRFB_FLAG_EDID_RDY 0x4000
+#define FMRFB_EDID_SIZE 256
+#define FMRFB_EDID_WAIT_TOUT 60
+
+#define VMODE_NAME_SZ (20 + 1)
+#define VMODE_OPTS_SZ (2 + 1)
+
+/* ------------------------------------------------------------ */
+/*					Miscellaneous Declarations					*/
+/* ------------------------------------------------------------ */
+
+#define CLK_BIT_WEDGE 13
+#define CLK_BIT_NOCOUNT 12
+
+/*
+ * WEDGE and NOCOUNT can't both be high, so this is used to signal an error state
+ */
+#define ERR_CLKDIVIDER (1 << CLK_BIT_WEDGE | 1 << CLK_BIT_NOCOUNT)
+
+#define ERR_CLKCOUNTCALC 0xFFFFFFFF //This value is used to signal an error
+
+#define OFST_DYNCLK_CTRL 0x0
+#define OFST_DYNCLK_STATUS 0x4
+#define OFST_DYNCLK_CLK_L 0x8
+#define OFST_DYNCLK_FB_L 0x0C
+#define OFST_DYNCLK_FB_H_CLK_H 0x10
+#define OFST_DYNCLK_DIV 0x14
+#define OFST_DYNCLK_LOCK_L 0x18
+#define OFST_DYNCLK_FLTR_LOCK_H 0x1C
+
+#define BIT_DYNCLK_START 0
+#define BIT_DYNCLK_RUNNING 0
+
+#define MMCM_FREQ_VCOMIN 600000
+#define MMCM_FREQ_VCOMAX 1200000
+#define MMCM_FREQ_PFDMIN 10000
+#define MMCM_FREQ_PFDMAX 450000
+#define MMCM_FREQ_OUTMIN 4000
+#define MMCM_FREQ_OUTMAX 800000
+#define MMCM_DIV_MAX 106
+#define MMCM_FB_MIN 2
+#define MMCM_FB_MAX 64
+#define MMCM_CLKDIV_MAX 128
+#define MMCM_CLKDIV_MIN 1
+
+#define FB_EVENT_FBI_UPDATE 0x01
+#define FB_FLAG_EDID_VMODE  0x20
+#define FB_FLAG_EDID_RDY    0x4000
+
+static const u64 lock_lookup[64] = {
+	0b0011000110111110100011111010010000000001,
+	0b0011000110111110100011111010010000000001,
+	0b0100001000111110100011111010010000000001,
+	0b0101101011111110100011111010010000000001,
+	0b0111001110111110100011111010010000000001,
+	0b1000110001111110100011111010010000000001,
+	0b1001110011111110100011111010010000000001,
+	0b1011010110111110100011111010010000000001,
+	0b1100111001111110100011111010010000000001,
+	0b1110011100111110100011111010010000000001,
+	0b1111111111111000010011111010010000000001,
+	0b1111111111110011100111111010010000000001,
+	0b1111111111101110111011111010010000000001,
+	0b1111111111101011110011111010010000000001,
+	0b1111111111101000101011111010010000000001,
+	0b1111111111100111000111111010010000000001,
+	0b1111111111100011111111111010010000000001,
+	0b1111111111100010011011111010010000000001,
+	0b1111111111100000110111111010010000000001,
+	0b1111111111011111010011111010010000000001,
+	0b1111111111011101101111111010010000000001,
+	0b1111111111011100001011111010010000000001,
+	0b1111111111011010100111111010010000000001,
+	0b1111111111011001000011111010010000000001,
+	0b1111111111011001000011111010010000000001,
+	0b1111111111010111011111111010010000000001,
+	0b1111111111010101111011111010010000000001,
+	0b1111111111010101111011111010010000000001,
+	0b1111111111010100010111111010010000000001,
+	0b1111111111010100010111111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010010110011111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111010001001111111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001,
+	0b1111111111001111101011111010010000000001
+};
+
+static const u32 filter_lookup_low[64] = {
+	0b0001011111,
+	0b0001010111,
+	0b0001111011,
+	0b0001011011,
+	0b0001101011,
+	0b0001110011,
+	0b0001110011,
+	0b0001110011,
+	0b0001110011,
+	0b0001001011,
+	0b0001001011,
+	0b0001001011,
+	0b0010110011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001010011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0001100011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010010011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011,
+	0b0010100011
+};
+
+struct vdmafb_vmode_data
+{
+	u32 ctrl_reg;
+	struct fb_videomode fb_vmode;
+	char fb_vmode_name[VMODE_NAME_SZ];
+	char fb_vmode_opts_cvt[VMODE_OPTS_SZ];
+	char fb_vmode_opts_ext[VMODE_OPTS_SZ];
+};
+
+struct vdmafb_layer_fix_data
+{
+	unsigned int offset;
+	unsigned short buffer_offset;
+	unsigned short width;
+	unsigned short height;
+	unsigned char bpp;
+	unsigned char bpp_virt;
+	unsigned char layer_type;
+	unsigned char alpha_mode;
+	/* higher 4 bits: number of layer buffers, lower 4 bits: layer ID */
+	unsigned char layer_fix_info;
+};
+
+// struct vdmafb_register_access {
+// 	u32 (*fmrfb_get_reg_val)
+// 		(void *reg_base_virt, unsigned long offset,
+// 		 struct fmrfb_layer_data *layer_data);
+// 	void (*fmrfb_set_reg_val)
+// 		(u32 value, void *reg_base_virt, unsigned long offset,
+// 		 struct fmrfb_layer_data *layer_data);
+// };
+
+struct vdmafb_sync {
+	wait_queue_head_t wait;
+	unsigned int cnt;
+};
+
+struct vdmafb_registers {
+	u32 ctrl_reg;
+	u32 dtype_reg;
+	u32 bg_reg;
+	u32 unused_reg[3];
+	u32 int_mask_reg;
+};
+
+struct vdmafb_common_data
+{
+	struct mutex irq_mutex;
+	// struct vdmafb_register_access reg_access;
+	struct vdmafb_registers *reg_list;
+	struct vdmafb_sync vsync;
+	struct vdmafb_vmode_data vmode_data;
+	struct vdmafb_vmode_data vmode_data_current;
+	struct blocking_notifier_head fmrfb_notifier_list;
+	struct notifier_block fmrfb_nb;
+	/* Delay after applying display power and
+		before applying display signals */
+	unsigned int power_on_delay;
+	/* Delay after applying display signal and
+		before applying display backlight power supply */
+	unsigned int signal_on_delay;
+	unsigned long fmrfb_flags;
+	unsigned char fmrfb_pixclk_src_id;
+	unsigned char fmrfb_layers;
+	unsigned char fmrfb_irq;
+	unsigned char fmrfb_use_ref;
+	unsigned char fmrfb_console_layer;
+	unsigned char fmrfb_bg_layer_bpp;
+	unsigned char fmrfb_bg_layer_alpha_mode;
+	/* higher 4 bits: display interface
+	   lower 4 bits: display color space */
+	unsigned char fmrfb_display_interface_type;
+};
+
+struct vdmafb_layer_data
+{
+	struct vdmafb_common_data *vdmafb_cd;
+	struct mutex layer_mutex;
+	dma_addr_t reg_base_phys;
+	dma_addr_t fb_phys;
+	void *reg_base_virt;
+	void *vtc_base_virt;
+	void *clk_base_virt;
+	void *fb_virt;
+	unsigned long fb_size;
+	void *layer_reg_base_virt;
+	void *layer_clut_base_virt;
+	struct vdmafb_layer_fix_data layer_fix;
+	struct vdmafb_layer_registers *layer_reg_list;
+	unsigned char layer_ctrl_flags;
+	unsigned char layer_use_ref;
+};
+
+typedef struct {
+		u32 clk0L;
+		u32 clkFBL;
+		u32 clkFBH_clk0H;
+		u32 divclk;
+		u32 lockL;
+		u32 fltr_lockH;
+} ClkConfig;
+
+typedef struct {
+		u32 freq;
+		u32 fbmult;
+		u32 clkdiv;
+		u32 maindiv;
+} ClkMode;
+
+struct vdmafb_init_data
+{
+	struct platform_device *pdev;
+	struct vdmafb_vmode_data vmode_data;
+	struct vdmafb_layer_fix_data lfdata[LOGICVC_MAX_LAYERS];
+	ClkConfig clkreg;
+	unsigned long vmem_base_addr;
+	unsigned long vmem_high_addr;
+	unsigned long vtc_baseaddr;
+	int vtc_size;
+	unsigned long clk_baseaddr;
+	int clk_size;
+	unsigned char clk_en;
+	unsigned char pixclk_src_id;
+	unsigned char layer_ctrl_flags[LOGICVC_MAX_LAYERS];
+	unsigned char layers;
+	unsigned char active_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+	unsigned char display_interface_type;
+	unsigned short flags;
+	bool vmode_params_set;
+};
+
+#endif
